<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Game (3D)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js library for 3D rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Tone.js library for sound effects -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        body {
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
            transition: background-color 0.5s ease-in-out;
        }

        #gameCanvas {
            background-color: #1a202c;
            border: 2px solid #4a5568;
            box-shadow: 0 0 20px rgba(0, 250, 0, 0.5);
            border-radius: 10px;
        }

        .message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(26, 32, 44, 0.95);
            border: 2px solid #48bb78;
            padding: 2rem;
            border-radius: 10px;
            text-align: center;
            color: #48bb78;
            font-size: 1.5rem;
            line-height: 2;
            z-index: 100;
            display: none;
        }

        .controls-button {
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            background-color: #48bb78;
            color: #1a202c;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px #2f855a;
            transition: all 0.2s ease-in-out;
            transform: translateY(0);
        }

        .controls-button:hover {
            background-color: #68d391;
            transform: translateY(-2px);
            box-shadow: 0 6px #2f855a;
        }

        .controls-button:active {
            transform: translateY(2px);
            box-shadow: 0 2px #2f855a;
        }
    </style>
</head>
<body class="bg-gray-900 flex items-center justify-center min-h-screen p-4 text-white">

    <div class="flex flex-col items-center p-8 bg-gray-800 rounded-xl shadow-2xl space-y-6 max-w-full">
        <h1 class="text-3xl sm:text-4xl text-green-400 mb-4 tracking-wider">SNAKE (3D)</h1>
        
        <div class="flex flex-col sm:flex-row items-center space-y-2 sm:space-y-0 sm:space-x-4 mb-4 text-xl sm:text-2xl">
            <div class="flex items-center space-x-2">
                <span class="text-gray-400">Score:</span>
                <span id="score" class="text-green-400 font-bold">0</span>
            </div>
            <div class="flex items-center space-x-2">
                <span class="text-gray-400">High Score:</span>
                <span id="highScore" class="text-yellow-400 font-bold">0</span>
            </div>
        </div>

        <div class="relative">
            <!-- Canvas dimensions are now set dynamically by JavaScript -->
            <canvas id="gameCanvas"></canvas>
            <div id="messageBox" class="message-box">
                <p id="messageText">Game Over!</p>
                <div class="mt-4 text-sm font-normal">
                    <p>Press <span class="text-green-400 font-bold">C</span> to Restart</p>
                    <p>Press <span class="text-red-400 font-bold">Q</span> to Quit</p>
                    <p>Press <span class="text-yellow-400 font-bold">P</span> to Pause</p>
                </div>
            </div>
        </div>

        <div class="flex flex-col sm:flex-row items-center justify-center space-y-4 sm:space-y-0 sm:space-x-4 w-full">
            <button id="restartButton" class="controls-button">Restart (C)</button>
            <button id="pauseButton" class="controls-button bg-yellow-500 shadow-yellow-700 hover:bg-yellow-600 hover:shadow-yellow-700">Pause (P)</button>
            <button id="quitButton" class="controls-button bg-red-500 shadow-red-700 hover:bg-red-600 hover:shadow-red-700">Quit (Q)</button>
        </div>

        <p class="text-sm text-gray-500 mt-4 tracking-wide text-center">Use **Arrow Keys** to move. Click and drag with mouse to rotate camera.</p>

    </div>

    <script>
        // Game constants
        const canvas = document.getElementById('gameCanvas');
        const scoreDisplay = document.getElementById('score');
        const highScoreDisplay = document.getElementById('highScore');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const restartButton = document.getElementById('restartButton');
        const pauseButton = document.getElementById('pauseButton');
        const quitButton = document.getElementById('quitButton');

        // Fixed grid dimensions for consistent gameplay
        const TILE_SIZE = 1;
        const GRID_WIDTH = 20; 
        const GRID_HALF = GRID_WIDTH / 2;
        let CANVAS_SIZE = 400;

        // Three.js variables
        let scene, camera, renderer;
        let snakeGroup, foodMesh, bonusFoodMesh;
        let snakeMaterials = [];
        let clock = new THREE.Clock();
        let particleSystem;
        const particleCount = 100;
        const particleGeometry = new THREE.BufferGeometry();
        const particleMaterial = new THREE.PointsMaterial({
            color: 0xffff00,
            size: 0.1,
            blending: THREE.AdditiveBlending,
            transparent: true,
            opacity: 1.0
        });
        const particles = [];
        let particleEffectActive = false;
        let particleTime = 0;

        // Game state variables
        let snake = [];
        let food = {};
        let direction = 'right';
        let score = 0;
        let highScore = parseInt(localStorage.getItem('snakeHighScore')) || 0;
        let gameInterval = null;
        let isGameOver = true;
        let isPaused = false;
        let lastDirection = '';
        let pendingDirection = '';
        let foodEatenCount = 0;
        let segmentsToGrow = 0;

        // Dynamic speed variables
        let gameSpeed = 100; // Initial interval in ms
        const speedIncreaseFactor = 0.95; // 5% speed increase
        const speedIncreaseInterval = 5; // Increase speed every 5 food items

        // Camera control variables
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        
        // Audio variables
        let eatSynth, gameOverSynth;

        // Function to initialize the 3D scene
        const initThreeJS = () => {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a202c);

            // Camera
            camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
            camera.position.set(0, 10, 20);
            camera.lookAt(new THREE.Vector3(0, 0, 0));

            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(CANVAS_SIZE, CANVAS_SIZE);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(10, 10, 10);
            scene.add(directionalLight);
            const pointLight = new THREE.PointLight(0xffffff, 1, 100);
            pointLight.position.set(0, 10, 0);
            scene.add(pointLight);

            // Add visible walls to clearly define the game area
            const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x4a5568, metalness: 0.3, roughness: 0.5 });
            const wallThickness = 0.5;
            const wallHeight = 1;

            // Top wall
            const topWall = new THREE.Mesh(new THREE.BoxGeometry(GRID_WIDTH, wallHeight, wallThickness), wallMaterial);
            topWall.position.set(0, GRID_HALF - wallHeight / 2, 0);
            scene.add(topWall);

            // Bottom wall
            const bottomWall = new THREE.Mesh(new THREE.BoxGeometry(GRID_WIDTH, wallHeight, wallThickness), wallMaterial);
            bottomWall.position.set(0, -GRID_HALF + wallHeight / 2, 0);
            scene.add(bottomWall);

            // Left wall
            const leftWall = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, GRID_WIDTH, wallThickness), wallMaterial);
            leftWall.position.set(-GRID_HALF + wallThickness / 2, 0, 0);
            scene.add(leftWall);

            // Right wall
            const rightWall = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, GRID_WIDTH, wallThickness), wallMaterial);
            rightWall.position.set(GRID_HALF - wallThickness / 2, 0, 0);
            scene.add(rightWall);

            // Snake and food groups
            snakeGroup = new THREE.Group();
            scene.add(snakeGroup);

            // Create materials for the snake gradient
            for (let i = 0; i < 200; i++) { // Max snake length
                const colorRatio = i / 200;
                const headColor = new THREE.Color(0x48bb78);
                const tailColor = new THREE.Color(0x38a169);
                const color = new THREE.Color().lerpColors(headColor, tailColor, colorRatio);
                snakeMaterials.push(new THREE.MeshStandardMaterial({ color: color, metalness: 0.2, roughness: 0.5 }));
            }
        };
        
        const initAudio = () => {
            // A more gentle synth for the eating sound
            eatSynth = new Tone.Synth({
                oscillator: { type: 'sine' },
                envelope: {
                    attack: 0.05,
                    decay: 0.2,
                    sustain: 0.1,
                    release: 0.4
                }
            }).toDestination();

            // A more quiet, gentle and short synth for the game over sound
            gameOverSynth = new Tone.Synth({
                oscillator: { type: 'sine' },
                envelope: {
                    attack: 0.05,
                    decay: 0.1,
                    sustain: 0.05,
                    release: 0.2
                }
            }).toDestination();
        };

        // Function to handle canvas resizing
        const resizeCanvas = () => {
            const parentWidth = canvas.parentElement.offsetWidth;
            const parentHeight = window.innerHeight - 200;
            
            CANVAS_SIZE = Math.min(parentWidth, parentHeight);
            
            renderer.setSize(CANVAS_SIZE, CANVAS_SIZE);
            camera.aspect = CANVAS_SIZE / CANVAS_SIZE; // Maintain a 1:1 aspect ratio
            camera.updateProjectionMatrix();

            // Adjust camera position to keep the view consistent
            const halfGridSize = (GRID_WIDTH * TILE_SIZE) / 2;
            camera.position.set(0, 10, halfGridSize * 2); 
            camera.lookAt(new THREE.Vector3(0, 0, 0));

            // Call animate to render the changes
            animate();
        };

        // Function to show a message in the message box
        const showMessage = (text) => {
            messageText.textContent = text;
            messageBox.style.display = 'block';
        };

        // Function to hide the message box
        const hideMessage = () => {
            messageBox.style.display = 'none';
        };

        // Function to create a particle effect
        const createParticleEffect = (x, y) => {
            const positions = [];
            for (let i = 0; i < particleCount; i++) {
                // Place particles at the food location
                positions.push(x * TILE_SIZE, y * TILE_SIZE, 0);
            }
            particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            particleSystem = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particleSystem);
            
            // Initialize particle velocity
            for (let i = 0; i < particleCount; i++) {
                particles.push({
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.2,
                        (Math.random() - 0.5) * 0.2,
                        (Math.random() - 0.5) * 0.2
                    ),
                    position: new THREE.Vector3(x * TILE_SIZE, y * TILE_SIZE, 0)
                });
            }
            
            particleEffectActive = true;
            particleTime = 0;
        };

        const updateParticles = () => {
            if (!particleEffectActive) return;

            const positionAttribute = particleSystem.geometry.getAttribute('position');
            for (let i = 0; i < particleCount; i++) {
                const particle = particles[i];
                particle.position.add(particle.velocity);

                positionAttribute.setXYZ(i, particle.position.x, particle.position.y, particle.position.z);
            }
            positionAttribute.needsUpdate = true;

            // Fade out particles
            particleMaterial.opacity = 1.0 - (particleTime / 1); // 1 second duration
            
            particleTime += clock.getDelta();
            
            if (particleTime > 1) { // Particle effect duration
                scene.remove(particleSystem);
                particleEffectActive = false;
            }
        };
        
        // Function to spawn food at a random valid location
        const spawnFood = (isBonus = false) => {
            let newFoodPos;
            do {
                // Prevent food from spawning on the outermost two edge tiles
                const minPos = -GRID_HALF + 2;
                const maxPos = GRID_HALF - 2;
                const range = maxPos - minPos + 1;
                newFoodPos = {
                    x: Math.floor(Math.random() * range) + minPos,
                    y: Math.floor(Math.random() * range) + minPos
                };
            } while (isPositionOnSnake(newFoodPos));
            
            // Clear existing food meshes
            if (foodMesh) scene.remove(foodMesh);
            if (bonusFoodMesh) scene.remove(bonusFoodMesh);
            foodMesh = null;
            bonusFoodMesh = null;
            
            if (isBonus) {
                food.isBonus = true;
                food.position = newFoodPos;
                const bonusFoodGeometry = new THREE.SphereGeometry(TILE_SIZE * 0.7, 16, 16);
                const bonusFoodMaterial = new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xffff00, emissiveIntensity: 0.8 });
                bonusFoodMesh = new THREE.Mesh(bonusFoodGeometry, bonusFoodMaterial);
                bonusFoodMesh.position.set(food.position.x * TILE_SIZE, food.position.y * TILE_SIZE, 0);
                scene.add(bonusFoodMesh);
            } else {
                food.isBonus = false;
                food.position = newFoodPos;
                const foodGeometry = new THREE.BoxGeometry(TILE_SIZE, TILE_SIZE, TILE_SIZE);
                const foodMaterial = new THREE.MeshStandardMaterial({ color: 0xf56565, metalness: 0.3, roughness: 0.5 });
                foodMesh = new THREE.Mesh(foodGeometry, foodMaterial);
                foodMesh.position.set(food.position.x * TILE_SIZE, food.position.y * TILE_SIZE, 0);
                scene.add(foodMesh);
            }
        };

        // Function to check if a position is on the snake's body
        const isPositionOnSnake = (position) => {
            // Check all segments of the snake, including the head
            for (let i = 0; i < snake.length; i++) {
                if (snake[i].x === position.x && snake[i].y === position.y) {
                    return true;
                }
            }
            return false;
        };

        // Function to update the 3D representation of the snake
        const updateSnakeMeshes = () => {
            while(snakeGroup.children.length > 0){
                snakeGroup.remove(snakeGroup.children[0]);
            }

            const geometry = new THREE.BoxGeometry(TILE_SIZE, TILE_SIZE, TILE_SIZE);
            for (let i = 0; i < snake.length; i++) {
                const materialIndex = Math.min(i, snakeMaterials.length - 1);
                const mesh = new THREE.Mesh(geometry, snakeMaterials[materialIndex]);
                mesh.position.set(snake[i].x * TILE_SIZE, snake[i].y * TILE_SIZE, 0);
                snakeGroup.add(mesh);
            }
        };

        // Function to update the game state
        const update = () => {
            if (isGameOver || isPaused) {
                return;
            }

            if (pendingDirection) {
                direction = pendingDirection;
                pendingDirection = '';
            }

            const newHead = { x: snake[0].x, y: snake[0].y };
            switch (direction) {
                case 'up': newHead.y++; break;
                case 'down': newHead.y--; break;
                case 'left': newHead.x--; break;
                case 'right': newHead.x++; break;
            }

            if (newHead.x < -GRID_HALF || newHead.x >= GRID_HALF || newHead.y < -GRID_HALF || newHead.y >= GRID_HALF) {
                endGame();
                return;
            }

            if (isPositionOnSnake(newHead)) {
                endGame();
                return;
            }

            snake.unshift(newHead);

            if (newHead.x === food.position.x && newHead.y === food.position.y) {
                if (food.isBonus) {
                    eatSynth.triggerAttackRelease("G4", "8n");
                    score += 5;
                    segmentsToGrow += 2;
                    foodEatenCount = 0;
                    createParticleEffect(food.position.x, food.position.y);
                } else {
                    eatSynth.triggerAttackRelease("C4", "8n");
                    score++;
                    segmentsToGrow += 1;
                    foodEatenCount++;
                }
                scoreDisplay.textContent = score;

                // Increase game speed every speedIncreaseInterval food items
                if (score > 0 && score % speedIncreaseInterval === 0 && !food.isBonus) {
                    gameSpeed = Math.max(50, gameSpeed * speedIncreaseFactor);
                    clearInterval(gameInterval);
                    gameInterval = setInterval(update, gameSpeed);
                }

                if (foodEatenCount > 0 && foodEatenCount % 5 === 0) {
                    spawnFood(true);
                } else {
                    spawnFood(false);
                }
            }

            if (segmentsToGrow > 0) {
                segmentsToGrow--;
            } else {
                snake.pop();
            }

            updateSnakeMeshes();
            lastDirection = direction;
        };

        // Main animation loop
        const animate = () => {
            requestAnimationFrame(animate);
            if (particleEffectActive) {
                updateParticles();
            }
            renderer.render(scene, camera);
        };

        // Function to handle game over
        const endGame = () => {
            isGameOver = true;
            clearInterval(gameInterval);
            gameInterval = null;
            gameOverSynth.triggerAttackRelease("C3", "1n");
            showMessage(`Game Over! Final Score: ${score}`);
            setHighScore(score);
        };

        const togglePause = () => {
            if (isGameOver) return;

            isPaused = !isPaused;
            if (isPaused) {
                clearInterval(gameInterval);
                pauseButton.textContent = "Resume (P)";
                showMessage("Game Paused");
            } else {
                gameInterval = setInterval(update, gameSpeed);
                pauseButton.textContent = "Pause (P)";
                hideMessage();
            }
        };

        // Function to handle quitting the game
        const quitGame = () => {
            isGameOver = true;
            clearInterval(gameInterval);
            gameInterval = null;
            gameOverSynth.triggerAttackRelease("C3", "1n");
            showMessage(`Game Quit! Final Score: ${score}`);
            setHighScore(score);
        };
        
        // Function to start the main game loop immediately
        const startGame = () => {
            hideMessage();
            if (gameInterval) {
                clearInterval(gameInterval);
            }
            isPaused = false;
            // Reset the game state before starting a new game
            resetGame();
            isGameOver = false;
            gameInterval = setInterval(update, gameSpeed);
            
            // Start the clock for animations
            clock.start();
            Tone.start();
        };

        const resetGame = () => {
            score = 0;
            scoreDisplay.textContent = score;
            highScoreDisplay.textContent = highScore;
            foodEatenCount = 0;
            segmentsToGrow = 0;
            gameSpeed = 100;
            
            snake = [{ x: 0, y: 0 }];
            direction = 'right';
            lastDirection = 'right';
            pendingDirection = '';

            if (foodMesh) scene.remove(foodMesh);
            if (bonusFoodMesh) scene.remove(bonusFoodMesh);
            
            spawnFood(false);
            updateSnakeMeshes();
        };

        const setHighScore = (newScore) => {
            if (newScore > highScore) {
                highScore = newScore;
                localStorage.setItem('snakeHighScore', highScore);
                highScoreDisplay.textContent = highScore;
            }
        };

        // Event listener for keyboard input
        document.addEventListener('keydown', (e) => {
            if (e.key === 'c' || e.key === 'C') {
                if (isGameOver) {
                    startGame();
                }
            } else if (e.key === 'q' || e.key === 'Q') {
                if (!isGameOver) {
                    quitGame();
                }
            } else if (e.key === 'p' || e.key === 'P') {
                togglePause();
            } else if (!isGameOver && !isPaused) {
                switch (e.key) {
                    case 'ArrowUp':
                        if (lastDirection !== 'down') { pendingDirection = 'up'; }
                        break;
                    case 'ArrowDown':
                        if (lastDirection !== 'up') { pendingDirection = 'down'; }
                        break;
                    case 'ArrowLeft':
                        if (lastDirection !== 'right') { pendingDirection = 'left'; }
                        break;
                    case 'ArrowRight':
                        if (lastDirection !== 'left') { pendingDirection = 'right'; }
                        break;
                }
            }
        });
        
        // Event listeners for buttons
        restartButton.addEventListener('click', () => {
            if (isGameOver) {
                startGame();
            }
        });

        pauseButton.addEventListener('click', togglePause);

        quitButton.addEventListener('click', () => {
            if (!isGameOver) {
                quitGame();
            }
        });

        // Mouse interaction for camera control
        canvas.addEventListener('mousedown', (e) => {
            if (isGameOver || isPaused) {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging) return;

            const deltaX = (e.clientX - previousMousePosition.x) * 0.005;
            const deltaY = (e.clientY - previousMousePosition.y) * 0.005;

            camera.rotation.y += deltaX;
            camera.rotation.x += deltaY;

            const PI_HALF = Math.PI / 2;
            camera.rotation.x = Math.max(-PI_HALF + 0.1, Math.min(PI_HALF - 0.1, camera.rotation.x));

            previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        // Initialize the game on load with a welcome message and resize
        window.onload = () => {
            initThreeJS();
            initAudio();
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            resetGame();
            showMessage("Position your camera with the mouse. Press 'C' or 'Restart' to begin!");
            animate();
        };
    </script>
</body>
</html>
